{
  "title": "API with a Rich Linguistic Resource",
  "abstract": "This paper introduces a novel Python API, incorporated within the NLTK library,\nthat facilitates access to the FrameNet 1.7 lexical database. The API enables pro-\ngrammatic processing of the lexicon, which is organized by frames, and annotated\nsentences. Additionally, it offers user-friendly displays accessible through the\ninteractive Python interface for browsing.",
  "introduction": "This paper delves into the significance of the Berkeley FrameNet project, an endeavor that has been\nongoing for over a decade. FrameNet meticulously documents the vocabulary of modern English,\nutilizing the framework of frame semantics. This freely available and linguistically comprehensive\nresource encompasses more than 1,000 semantic frames, 10,000 lexical senses, and 100,000 lexical\nannotations embedded within corpus sentences. It has served as a foundational element for extensive\nresearch in natural language processing, particularly in the area of semantic role labeling.\n\nDespite FrameNet\u2019s importance, computational users frequently encounter obstacles due to the\ncomplexity of its custom XML format. While the resource is largely navigable on the web, some\ndetails pertaining to linguistic descriptions and annotations are not easily accessible through the\nHTML data views. Furthermore, the few existing open-source APIs for interacting with FrameNet\ndata have become outdated and have not achieved widespread adoption.\n\nThis paper introduces a new, easy-to-use Python API that provides a way to explore FrameNet data.\nThis API is integrated into recent versions of the widely-used NLTK suite and grants access to nearly\nall of the information within the FrameNet release.\n\n2\n\nInstallation\n\nTo install NLTK, please refer to the instructions at nltk.org. NLTK offers cross-platform functionality\nand is compatible with both Python 2.7 and Python 3.x environments. It is also included in the\nAnaconda and Enthought Canopy Python distributions, which are frequently utilized by data scientists.\n\nIn an active NLTK setup (version 3.2.2 or later), the FrameNet data can be downloaded through a\nsingle method call:\n\n>>> import nltk\n>>> nltk.download(\u2019framenet_v17\u2019)\n\nThe data will be installed under the user\u2019s home directory by default. Note that Frame-to-frame\nrelations include mappings between individual frame elements. These mappings are not exposed in\nthe HTML frame definitions on the website but can be explored visually via the FrameGrapher tool\non the website. Our API does not display these relations directly in the frame display but rather via\nindividual frame relation objects or the fe_relations() method, as discussed in Section 4.4.\n\n38th Conference on Neural Information Processing Systems (NeurIPS 2024).\n\n\f3 Overview of FrameNet\n\nFrameNet is built around conceptual structures called frames. A semantic frame depicts a situation,\nwhich could be an event, a state, or any other scenario that can be either universal or specific to a\nculture, as well as either broad or narrow in scope. The frame identifies participant roles known as\nframe elements (FEs). These relationships create the conceptual framework necessary to understand\ncertain meanings of vocabulary items.\n\nSome examples include:\n\n\u2022 Verbs like buy, sell, and pay, along with nouns like buyer, seller, price, and purchase, are\ndefined within a commercial transaction scenario (frame). Central FEs in this frame, which\nmay be explicitly mentioned in a text or not, include the Buyer, the Seller, the Goods being\nsold, and the Money that is paid.\n\n\u2022 The notion of REVENGE, manifested in words such as revenge, avenge, avenger, retaliate,\npayback, and get even, fundamentally relies on an Injury that an Offender has inflicted upon\nan Injured_party. An Avenger (who might or might not be the same as the Injured_party)\nattempts to impose a Punishment on the Offender.\n\n\u2022 A hypotenuse implies a geometrical concept of a right triangle, whereas a pedestrian suggests\n\na street with both vehicular and nonvehicular traffic.\n\nThe FEs within a frame are formally enumerated, along with a description of their role within the\nframe. Frames are connected in a network, which includes a hierarchy where one frame inherits from\nanother, and other frame-to-frame relationships. Vocabulary items that are part of a frame are called\nlexical units (LUs). FrameNet\u2019s LUs include both content and function words, linking a lemma to a\nframe.\n\nIn a text, an LU token is said to evoke the frame. Sentences are annotated with regard to frame-\nevoking tokens and the spans of their FEs. For example, in \"[Snape]Injured_party\u2019s revenge [on\nHarry]Offender\", the labels denote the participants of the REVENGE frame.\n\n4 API Overview\n\n4.1 Design Principles\n\nThe API is built with these principles in mind:\n\n\u2022 Simplicity: Access to the main database objects, such as frames, lexical units, and annota-\ntions, should be simple, whether through iteration or targeted searches. To avoid overloading\nthe API with methods, additional details can be accessed as object attributes. The help()\nmethod provides a synopsis of key database access methods.\n\n\u2022 Discoverability: Given the database\u2019s complexity, the API makes it easy to browse objects\nusing the Python interactive prompt. This is mainly accomplished through well-formatted\nobject displays, similar to the frame display in Figure 1 (see Section 4.3). These displays\nshow users how to access object attributes they might not otherwise be aware of.\n\n\u2022 On-demand loading: The database is split into many XML files. The FrameNet 1.7 release,\nonce unzipped, is 855 MB. Loading all of these files, particularly the corpus annotations, is\nslow and resource-intensive. The API uses lazy data structures to load XML files only as\nrequired, storing all loaded data in memory for quick subsequent access.\n\n4.2 Lexicon Access Methods\n\nThe primary methods for accessing lexicon data are:\n\n\u2022 frames(name): returns all frames matching the provided name pattern.\n\u2022 frame(nameOrId): returns a single frame matching the name or the ID\n\u2022 lus(name, frame): returns all lexical units matching the provided name pattern.\n\u2022 lu(id): returns a lexical unit based on its ID\n\n2\n\n\f\u2022 fes(name, frame): returns all frame elements based on the name pattern provided\n\nMethods with plural names use regular expressions to search entries. Also, the lus() and fes()\nmethods allow you to specify a frame to constrain the results. These methods return lists of elements,\nand if no arguments are provided, they return all entries of the lexicon.\n\nBelow is an example of a search using the frame name pattern:\n\n>>> fn.frames(\u2019(?i)creat\u2019)\n[<frame ID=268 name=Cooking_creation>, <frame ID=1658 name=Create_physical_artwork>, ...]\n\nHere is an example of a search using the LU name pattern, note that the .v suffix is used for all verbal\nLUs:\n\n>>> fn.lus(r\u2019.+en\\\\.v\u2019)\n[<lu ID=5331 name=awaken.v>, <lu ID=7544 name=betoken.v>, ...]\n\nThe frame() and lu() methods are used to get an entry by name or ID. A FramenetError will be\nraised when trying to retrieve a non-existent entry.\n\nTwo extra methods are available for frame lookups: frame_ids_and_names(name) gets a mapping\nfrom frame IDs to names and frames_by_lemma(name) returns all the frames that have LUs\nmatching the provided name pattern.\n\n4.3 Database Objects\n\nAll structured objects like frames, LUs, and FEs are loaded as AttrDict data structures, where keys\ncan be accessed as attributes. For instance:\n\n>>> f = fn.frame(\u2019Revenge\u2019)\n>>> f.keys()\ndict_keys([\u2019cBy\u2019, \u2019cDate\u2019, \u2019name\u2019, \u2019ID\u2019, \u2019_type\u2019, \u2019definition\u2019,\n\u2019definitionMarkup\u2019, \u2019frameRelations\u2019, \u2019FE\u2019, \u2019FEcoreSets\u2019,\n\u2019lexUnit\u2019, \u2019semTypes\u2019, \u2019URL\u2019])\n>>> f.name\n\u2019Revenge\u2019\n>>> f.ID\n347\n\nThe API provides user-friendly displays for important object types, presenting their contents in an\norganized manner. For example, calling fn.frame(\u2019Revenge\u2019) prints the display for the REVENGE\nframe. These displays indicate attribute names in square brackets.\n\nframe (347): Revenge\n[URL] https://framenet2.icsi.berkeley.edu/fnReports/data/frame/Revenge.xml\n[definition]\nThis frame concerns the infliction of punishment in return for a wrong suffered. An Avenger performs a Punishment on a Offender as a consequence of an earlier action by the Offender, the Injury. The Avenger inflicting thePunishment need not be the same as the Injured_Party who suffered the Injury, but the Avenger does have to share the judgment that the Offender\u2019s action was wrong. The judgment that the Offender had inflicted an Injury is made without regard to the law. \u2019(1) They took revenge for the deaths of two loyalist prisoners.\u2019 \u2019(2) Lachlan went out to avenge them.\u2019 \u2019(3) The next day, the Roman forces took revenge on their enemies..\u2019\n[semTypes] 0 semantic types\n[frameRelations] 1 frame relations <Parent=Rewards_and_punishments -- Inheritance -> Child=Revenge>\n[lexUnit] 18 lexical units avenge.v (6056), avenger.n (6057), get back (at).v (10003), get even.v (6075), payback.n (10124), retaliate.v (6065), retaliation.n (6071), retribution.n (6070), retributive.a (6074), retributory.a (6076), revenge.n (6067), revenge.v (6066), revengeful.a (6073), revenger.n (6072), sanction.n (10676), vengeance.n (6058), vengeful.a (6068), vindictive.a (6069)\n[FE] 14 frame elements Core: Avenger (3009), Injured_party (3022), Injury (3018), Offender (3012), Punishment (3015) Peripheral: Degree (3010), Duration (12060), Instrument (3013), Manner (3014), Place (3016), Purpose (3017), Time (3021) Extra-Thematic: Depictive (3011), Result (3020)\n[FEcoreSets] 2 frame element core sets Injury, Injured_party Avenger, Punishment\n\n4.4 Advanced Lexicon Access\n\nFrame relations. Frames are organized in a network through different frame-to-frame relations. For\nexample, the REVENGE frame is related to the REWARDS_AND_PUNISHMENTS frame through\nInheritance. Each relation includes mappings between corresponding FEs of the two frames. These\nrelations can be browsed with the frame_relations(frame, frame2, type) method. Within a\nframe relation object, mappings between FEs are stored in the feRelations attribute. The method\nfe_relations() gives direct access to the links between FEs. The available relation types can be\nobtained by frame_relation_types().\n\n3\n\n\fSemantic types. Semantic types provide added semantic labels for FEs, frames, and LUs. For FEs,\nthey show selectional constraints. The method propagate_semtypes() propagates the semantic\ntype labels to other FEs using inference rules derived from FE relations. The semtypes() method\nreturns all semantic types, semtype() returns a specific type, and semtype_inherits() checks if\ntwo semantic types are in a subtype-supertype relationship.\n\n4.5 Corpus Access\n\nFrame annotations of sentences are accessible through the exemplars and subCorpus attributes of\na LU object or using the following methods:\n\n\u2022 annotations(luname, exemplars, full_text)\n\u2022 sents()\n\u2022 exemplars(luname)\n\u2022 ft_sents(docname)\n\u2022 doc(id)\n\u2022 docs(name)\n\nThe annotations() method returns a list of frame annotation sets. These sets comprise a frame-\nevoking target in a sentence, the LU in the frame, the FEs found in the sentence, and the status of any\nnull-instantiated FEs. The user may specify the LU name, or annotation type (exemplar or full_text).\n\nCorpus sentences are accessed in two forms: exemplars() gives sentences with lexicographic\nannotations, and ft_sents() gives sentences from full-text annotations. sents() provides an\niterator over all sentences. Each sentence object has several annotation sets, the first is for sentence\nlevel annotations, the following for frame annotations.\n\nexemplar sentence (929548):\n[sentNo] 0\n[aPos] 1113164\n[LU] (6067) revenge.n in Revenge\n[frame] (347) Revenge\n[annotationSet] 2 annotation sets\n[POS] 12 tags\n[POS_tagset] BNC\n[GF] 4 relations\n[PT] 4 phrases\n[text] + [Target] + [FE] + [Noun]\nA short while later Joseph had his revenge on Watney \u2019s .\n\n[Injury:DNI] (Avenge=Avenger, sup=supp, Ave=Avenger)\n\nTime\n\nOffender\n\nfull-text sentence (4148528) in Tiger_Of_San_Pedro:\n[POS] 25 tags\n[POS_tagset] PENN\n[text] + [annotationSet]\nThey \u2019ve been looking for him all the time for their revenge , ******* ******* Seeking Revenge [3] ? [2]\nbut it is only now that they have begun to find him out . \" ***** **** Proce Beco [1] [4]\n(Proce=Process_start, Beco=Becoming_aware)\n\n5 Limitations and Future Work\n\nThe main FrameNet component that the API does not support right now is valence patterns, which\nsummarize the FE\u2019s syntactic realizations across annotated tokens for an LU. In the future, we intend\nto include support for valence patterns, along with improved capabilities for annotation querying, and\nbetter syntactic information displays for FE annotations. Moreover, it is worth investigating whether\nthe API can be modified to work with other language FrameNets, also to support cross-lingual\nmappings.\n\n4",
  "related_work": "",
  "methodology": "",
  "experiments": "",
  "results": "",
  "conclusion": "",
  "is_publishable": 1,
  "venue": NaN
}